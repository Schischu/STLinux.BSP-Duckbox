--- aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/main.c.org	2013-05-26 13:32:36.000000000 +0200
+++ aio-grab-47983a78821c0fdbef3aab36113d5c6fc34bb11b/main.c	2013-05-31 11:26:31.199745006 +0200
@@ -37,9 +37,93 @@
 #include <sys/mman.h>
 #include <linux/types.h>
 #include <linux/fb.h>
+#include <bpamem.h>
 #include "png.h"
 #include "jpeglib.h"
 
+#define OUT(x) \
+	out[outiter]=(unsigned char)*(decode_surface + x)&0xFF; \
+	outiter+=outinc;
+
+#define OUT4(x) \
+	OUT(x + 0x03); \
+	OUT(x + 0x02); \
+	OUT(x + 0x01); \
+	OUT(x + 0x00);
+
+#define OUT8(x) \
+	OUT4(x + 0x04); \
+	OUT4(x + 0x00);
+
+#define OUT16A(x) \
+	OUT8(x); \
+	OUT8(x + 0x40);
+
+#define OUT16A_C(x) \
+	OUT4(x); \
+	OUT4(x + 0x20); \
+	OUT4(x + 0x80); \
+	OUT4(x + 0xA0);
+
+//x: macroblock address
+//l: line 0-15
+#define OUT16(x,l) \
+	OUT16A(x + (l/4) * 0x10 + (l%2) * 0x80 + ((l/2)%2?0x00:0x08));
+
+//x: macroblock address
+//l: line 0-7
+//b: 0=cr 1=cb
+#define OUT16_C(x,l,b) \
+	OUT16A_C(x + (l/4) * 0x10 + (l%2) * 0x40 + ((l/2)%2?0x00:0x08) + (b?0x04:0x00));
+
+//x: first macroblock address
+//l: line 0-15 of macroblock line
+//s: stride by factor 16, e.g. 1280=80
+#define OUTL(x,l,s) \
+	{ \
+		int iMacro; \
+		for(iMacro = 0; iMacro < s; iMacro++) \
+		{ \
+			OUT16(x + iMacro*0x200, l); \
+		} \
+	}
+
+//x: first macroblock address
+//l: line 0-7
+//s: stride by factor 16, e.g. 1280=80
+//b: 0=cr 1=cb
+#define OUTL_C(x,l,s, b) \
+	{ \
+		int iMacro; \
+		for(iMacro = 0; iMacro < s; iMacro++) \
+		{ \
+			OUT16_C(x + iMacro*0x200, l, b); \
+		} \
+	}
+
+//x: first macroblock address
+//s: stride by factor 16, e.g. 1280=80
+#define OUTL_16(x,s) \
+	{ \
+		int l; \
+		for(l = 0; l < 16; l++) \
+		{ \
+			OUTL(x, l, s); \
+		} \
+	}
+
+//x: first macroblock address
+//s: stride by factor 16, e.g. 1280=80
+//b: 0=cr 1=cb
+#define OUTL_16_C(x,s,b) \
+	{ \
+		int l; \
+		for(l = 0; l < 8; l++) \
+		{ \
+			OUTL_C(x, l, s, b); \
+		} \
+	}
+
 #define CLAMP(x)    ((x < 0) ? 0 : ((x > 255) ? 255 : x))
 #define SWAP(x,y)	{ x ^= y; y ^= x; x ^= y; }
 
@@ -82,8 +166,8 @@
 void (*resize)(const unsigned char *source, unsigned char *dest, int xsource, int ysource, int xdest, int ydest, int colors);
 void combine(unsigned char *output, const unsigned char *video, const unsigned char *osd, int vleft, int vtop, int vwidth, int vheight, int xres, int yres);
 
-enum {UNKNOWN,PALLAS,VULCAN,XILLEON,BRCM7400,BRCM7401,BRCM7405,BRCM7335,BRCM7358};
-char *stb_name[]={"unknown","Pallas","Vulcan","Xilleon","Brcm7400","Brcm7401","Brcm7405","Brcm7335","Brcm7358"};
+enum {UNKNOWN,PALLAS,VULCAN,XILLEON,BRCM7400,BRCM7401,BRCM7405,BRCM7335,BRCM7358,ST};
+char *stb_name[]={"unknown","Pallas","Vulcan","Xilleon","Brcm7400","Brcm7401","Brcm7405","Brcm7335","Brcm7358","ST"};
 int stb_type=UNKNOWN;
 
 // main program
@@ -124,6 +208,7 @@
 		if (strcasestr(buf,"PALLAS")) stb_type=PALLAS;
 		if (strcasestr(buf,"XILLEON")) stb_type=XILLEON;
 		if (strcasestr(buf,"BCM7401") || strcasestr(buf,"BCMFB")) stb_type=BRCM7401;
+		if (strcasestr(buf,"STi")) stb_type=ST;
 	}
 	pclose(pipe);
 
@@ -645,7 +730,156 @@
 	char buf[256];
 	FILE *pipe;
 
-	if (stb_type == BRCM7401 || stb_type == BRCM7400 || stb_type == BRCM7405 || stb_type == BRCM7335 || stb_type == BRCM7358)
+	if (stb_type == ST)
+	{
+		int yblock, xblock, iyblock, yblockoffset, offset, outiter, outoffset, outinc;
+		unsigned char *out;
+		int fd_bpa;
+		int ioctlres;
+		BPAMemMapMemData bpa_data;
+		char bpa_mem_device[30];
+		char *decode_surface;
+	
+		pipe = fopen("/proc/stb/vmpeg/0/xres","r");
+		if (pipe)
+		{
+			while (fgets(buf,sizeof(buf),pipe))
+			{
+				sscanf(buf,"%x",&stride);
+			}
+			fclose(pipe);
+		}
+		pipe = fopen("/proc/stb/vmpeg/0/yres","r");
+		if (pipe)
+		{
+			while (fgets(buf,sizeof(buf),pipe))
+			{
+				sscanf(buf,"%x",&res);
+			}
+			fclose(pipe);
+		}
+
+		//if stride and res is zero than this is most probably a stillpicture
+		if(stride == 0) stride = 1280;
+		if(res == 0) res = 720;
+
+		luma   = (unsigned char *)malloc(stride * res);
+		chroma = (unsigned char *)malloc(stride * res / 2);
+
+		fd_bpa = open("/dev/bpamem0", O_RDWR);
+	
+		if(fd_bpa < 0)
+		{
+			fprintf(stderr, "cannot access /dev/bpamem0! err = %d\n", fd_bpa);
+			return 1;
+		}
+	
+		bpa_data.bpa_part  = "LMI_VID";
+
+
+		pipe = fopen("/proc/bpa2","r");
+		if (pipe)
+		{
+			unsigned char found_part = 0;
+			while (fgets(buf,sizeof(buf),pipe))
+			{
+				if(found_part || strstr(buf, bpa_data.bpa_part) != NULL)
+				{
+					found_part = 1;
+					if (sscanf(buf, "- %lu B at %lx", &bpa_data.mem_size, &bpa_data.phys_addr) == 2)
+						break;;
+				}
+			}
+			fclose(pipe);
+		}
+
+		printf("Using bpa2 part %s - 0x%lx %lu\n", bpa_data.bpa_part, bpa_data.phys_addr, bpa_data.mem_size);
+
+		//bpa_data.phys_addr = 0x4a824000;
+		//bpa_data.mem_size = 28311552;
+	
+		ioctlres = ioctl(fd_bpa, BPAMEMIO_MAPMEM, &bpa_data); // request memory from bpamem
+		if(ioctlres)
+		{
+			fprintf(stderr, "cannot map required mem\n");
+			return 1;
+		}
+	
+		sprintf(bpa_mem_device, "/dev/bpamem%d", bpa_data.device_num);
+		close(fd_bpa);
+	
+		fd_bpa = open(bpa_mem_device, O_RDWR);
+	
+		// if somebody forgot to add all bpamem devs then this gets really bad here
+		if(fd_bpa < 0)
+		{
+			fprintf(stderr, "cannot access %s! err = %d\n", bpa_mem_device, fd_bpa);
+			return 1;
+		}
+	
+		decode_surface = (char *)mmap(0, bpa_data.mem_size, PROT_WRITE|PROT_READ, MAP_SHARED, fd_bpa, 0);
+	
+		if(decode_surface == MAP_FAILED) 
+		{
+			fprintf(stderr, "could not map bpa mem");
+			close(fd_bpa);
+			return 1;
+		}
+
+		//luma
+		offset = 0;
+		yblock = res/16;  //45
+		xblock = stride/16; //80
+		yblockoffset = stride*32; //0xA000
+		outiter = 0;
+		outoffset = 0;
+		outinc = 1;
+		out = luma;
+		
+		for (iyblock = 0; iyblock < yblock; iyblock++)
+		{
+			OUTL_16(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000) + offset, xblock);
+		}
+		
+		//chroma
+		offset = ((stride*res + yblockoffset/2 /*round up*/) / yblockoffset) * yblockoffset;
+		//cb
+		yblock = res/16; //45
+		xblock = (stride/2)/16; //40
+		yblockoffset = (stride/2)*8/*h in block*/*2/*y blocks*/*2/*cr cb*/; //16pixel per x block and 2 y blocks//0x5000
+		outiter = 0;
+		outinc = 2;
+		out = chroma;
+		
+		for (iyblock = 0; iyblock < yblock; iyblock++)
+		{
+			OUTL_16_C(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000) + offset, xblock, 1);
+		}
+
+		//cr
+		yblock = res/16; //45
+		xblock = (stride/2)/16; //40
+		yblockoffset = (stride/2)*8/*h in block*/*2/*y blocks*/*2/*cr cb*/; //16pixel per x block and 2 y blocks//0x5000
+		outiter = 1;
+		outinc = 2;
+		out = chroma;
+		
+		for (iyblock = 0; iyblock < yblock; iyblock++)
+		{
+			OUTL_16_C(((iyblock/2) * yblockoffset) + (iyblock%2?0x0100:0x0000) + offset, xblock, 0);
+		}
+		
+		ioctlres = ioctl(fd_bpa, BPAMEMIO_UNMAPMEM); // request memory from bpamem
+		if(ioctlres)
+		{
+			fprintf(stderr, "cannot unmap required mem\n");
+			close(fd_bpa);
+			return 1;
+		}
+
+		close(fd_bpa);
+	}
+	else if (stb_type == BRCM7401 || stb_type == BRCM7400 || stb_type == BRCM7405 || stb_type == BRCM7335 || stb_type == BRCM7358)
 	{
 		// grab brcm7401 pic from decoder memory
 		const unsigned char* data = (unsigned char*)mmap(0, 100, PROT_READ, MAP_SHARED, mem_fd, (stb_type == BRCM7358) ? 0x10600000 : 0x10100000);
@@ -1059,12 +1293,14 @@
 			// now we do 4 pixels on each iteration this is more code but much faster
 			int Y=yuv2rgbtable_y[luma[pos]];
 
+			//p0:0
 			video[out1]=CLAMP((Y + RU)>>16);
 			video[out1+1]=CLAMP((Y - GV - GU)>>16);
 			video[out1+2]=CLAMP((Y + BV)>>16);
 
 			Y=yuv2rgbtable_y[luma[stride+pos]];
 
+			//p1:0
 			video[out1+rgbstride]=CLAMP((Y + RU)>>16);
 			video[out1+1+rgbstride]=CLAMP((Y - GV - GU)>>16);
 			video[out1+2+rgbstride]=CLAMP((Y + BV)>>16);
@@ -1074,12 +1310,14 @@
 
 			Y=yuv2rgbtable_y[luma[pos]];
 
+			//p0:1
 			video[out1]=CLAMP((Y + RU)>>16);
 			video[out1+1]=CLAMP((Y - GV - GU)>>16);
 			video[out1+2]=CLAMP((Y + BV)>>16);
 
 			Y=yuv2rgbtable_y[luma[stride+pos]];
 
+			//p1:1
 			video[out1+rgbstride]=CLAMP((Y + RU)>>16);
 			video[out1+1+rgbstride]=CLAMP((Y - GV - GU)>>16);
 			video[out1+2+rgbstride]=CLAMP((Y + BV)>>16);
